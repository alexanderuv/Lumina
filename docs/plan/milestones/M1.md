# Milestone 1 (M1) — Detailed Plan

**Scope**: Wave A (Linux) + Wave B (macOS)

**Timeline Target**: Q2 2026 (estimated)

**Prerequisite**: M0 (Wave A macOS & Windows) must be complete

---

## 1. Overview

Milestone 1 extends Lumina's core windowing and input capabilities to Linux platforms (X11 and Wayland) while simultaneously hardening the macOS implementation with robust redraw discipline, advanced window controls, and essential system integration features.

**Key Objectives**:
- Achieve Wave A feature parity on Linux (X11 and Wayland backends)
- Implement Wave B robustness and system integration features on macOS
- Maintain API consistency across all three platforms (macOS, Windows, Linux)
- Establish cross-platform testing infrastructure for Linux environments

---

## 2. Functional Requirements

### 2.1 Wave A — Linux (X11 + Wayland)

All features from Wave A that were completed for macOS and Windows in M0 must now work on Linux:

#### 2.1.1 App & Event Loop Basics
- [ ] **Run/Poll Modes**: Application can start event loop in blocking (`run()`) or non-blocking (`poll()`) modes
- [ ] **Low-Power Wait**: Event loop efficiently waits for events without spinning CPU
- [ ] **User Events**: Applications can post custom events to the event queue from any thread
- [ ] **Event Dispatching**: Events are delivered in deterministic order with proper type discrimination

#### 2.1.2 Window Fundamentals
- [ ] **Create/Show/Close**: Windows can be created with initial properties, shown, hidden, and destroyed
- [ ] **Title**: Window title can be set and updated at runtime
- [ ] **Resizable**: Windows can be marked resizable or fixed-size; behavior respects window manager policies
- [ ] **Min/Max Size**: Minimum and maximum size constraints are enforced by the window manager
- [ ] **Visibility**: Window visibility can be toggled; visibility change events are emitted
- [ ] **Focus**: Focus state is tracked; focus gained/lost events are delivered
- [ ] **Move/Resize**: Windows can be programmatically moved and resized; events reflect user/WM-initiated changes

#### 2.1.3 DPI/Scaling
- [ ] **Logical vs Physical Sizes**: Clear type-level distinction between logical pixels and physical pixels
- [ ] **Scale Factor**: Current scale factor is queryable per window
- [ ] **Scale Change Events**: Applications receive events when DPI or scale factor changes (monitor move, system settings)
- [ ] **Initial Scale Detection**: Windows start with correct scale factor based on monitor placement

#### 2.1.4 Pointer & Wheel Input
- [ ] **Pointer Move**: Cursor position updates delivered as events with logical coordinates
- [ ] **Enter/Leave**: Window enter/leave events track cursor presence
- [ ] **Mouse Buttons**: Left, right, middle, and additional button events (down/up)
- [ ] **Wheel Scrolling**: Vertical and horizontal scroll events with appropriate units
- [ ] **Precision Scrolling**: High-resolution scroll deltas on supported devices (e.g., touchpads)

#### 2.1.5 Keyboard Input (Basic)
- [ ] **Key Down/Up**: Physical key press and release events
- [ ] **Modifiers**: Shift, Control, Alt, Super (Meta) state tracking
- [ ] **Text Input**: Character input events for Latin layouts
- [ ] **Repeat Handling**: Key repeat events follow system settings
- [ ] **Focus Context**: Keyboard events only delivered to focused windows

#### 2.1.6 System Cursors
- [ ] **Default Cursor Set**: Standard cursors (arrow, hand, text beam, crosshair, resize variants, etc.)
- [ ] **Cursor Change**: Application can set cursor per window
- [ ] **Show/Hide**: Cursor visibility toggle
- [ ] **System Integration**: Cursors match system theme on Linux desktop environments

#### 2.1.7 Platform-Specific Considerations
- [ ] **X11 Backend**: Uses XCB or Xlib; handles window manager hints correctly
- [ ] **Wayland Backend**: Implements core protocols (xdg-shell); graceful degradation for missing compositor features
- [ ] **Protocol Fallbacks**: Capability detection for optional Wayland protocols; clear error messages when features unavailable

---

### 2.2 Wave B — macOS Robustness & Integration

These features are implemented on macOS first, establishing patterns for cross-platform implementation in M2:

#### 2.2.1 Redraw Contract
- [ ] **Explicit Redraw Events**: Applications receive `RedrawRequested` events when rendering is needed
- [ ] **Request Redraw API**: Applications can request redraws programmatically
- [ ] **Coalesced Resizes**: Rapid resize operations are coalesced to avoid redundant redraws
- [ ] **Frame Pacing**: Events support deterministic frame pacing for animations
- [ ] **Dirty Region Hints**: Optional dirty rectangle information when available from OS

#### 2.2.2 Control Flow Modes
- [ ] **Wait Mode**: Event loop blocks until events arrive (default, low power)
- [ ] **Poll Mode**: Event loop returns immediately after processing available events
- [ ] **WaitUntil Mode**: Event loop blocks until events or a deadline expires
- [ ] **Mode Switching**: Applications can switch between modes at runtime
- [ ] **Timeout Precision**: WaitUntil deadlines are accurate within OS scheduler limits

#### 2.2.3 Window Decorations & Styles
- [ ] **Toggle Decorations**: Remove or restore title bar and borders at runtime
- [ ] **Always-On-Top**: Windows can be marked to float above other windows
- [ ] **Transparency**: Window supports transparent background (alpha channel)
- [ ] **Shadow Control**: Platform-appropriate shadow rendering for decorated/undecorated windows
- [ ] **Traffic Light Controls**: macOS-specific title bar button positioning and visibility

#### 2.2.4 Clipboard (Text)
- [ ] **Read Text**: Query clipboard for UTF-8 text content
- [ ] **Write Text**: Set clipboard to UTF-8 text content
- [ ] **Ownership Tracking**: Detect when clipboard contents change externally
- [ ] **Thread Safety**: Clipboard operations safe from non-main threads with appropriate synchronization
- [ ] **Format Negotiation**: Proper UTI/MIME type handling for text formats

#### 2.2.5 Monitor Enumeration (Basic)
- [ ] **Primary Monitor**: Identify system's primary display
- [ ] **Monitor List**: Enumerate all connected monitors
- [ ] **Geometry**: Query physical position and dimensions for each monitor
- [ ] **Work Area**: Query usable area excluding menu bars, docks, taskbars
- [ ] **Monitor from Window**: Determine which monitor a window currently resides on
- [ ] **Change Events**: Applications notified when monitor configuration changes

---

## 3. Definition of Done

### 3.1 Functional Completeness
- [ ] All requirements in Section 2 are implemented and verified
- [ ] Wave A features work identically on macOS, Windows, X11, and Wayland (except documented platform limitations)
- [ ] Wave B features are fully functional on macOS with documented API surface
- [ ] No placeholder or stub implementations remain in M1 scope

### 3.2 Testing
- [ ] Unit tests pass on all platforms (macOS, Windows, Linux X11, Linux Wayland)
- [ ] Integration tests verify cross-platform behavior consistency
- [ ] Golden event trace tests validate event sequences for key interactions
- [ ] Manual testing checklist completed on:
  - [ ] macOS (latest two major versions)
  - [ ] Ubuntu 24.04 LTS (X11 session)
  - [ ] Ubuntu 24.04 LTS (Wayland session)
  - [ ] Fedora 40 (Wayland)
  - [ ] Arch Linux (window manager variety: GNOME, KDE, i3/sway)
- [ ] DPI scaling tests pass at 1.0x, 1.5x, 2.0x, and mixed-DPI scenarios
- [ ] Clipboard interop tests verify exchange with native apps

### 3.3 Documentation
- [ ] API documentation complete for all public types and methods
- [ ] Platform behavior differences documented in capability matrix
- [ ] Migration guide for M0 → M1 API changes (if any)
- [ ] Examples updated/added:
  - [ ] "Hello Window" example runs on all platforms
  - [ ] "Input Explorer" example demonstrates all Wave A input types
  - [ ] "Scaling Demo" example visualizes DPI changes
  - [ ] "Clipboard Text" example (Wave B) for macOS
  - [ ] "Frame Pacing" example (Wave B) for macOS
- [ ] README includes Linux build and runtime dependencies

### 3.4 Release Readiness
- [ ] Versioned as `0.2.0` (following Wave A = 0.1.0)
- [ ] CHANGELOG.md updated with all new features and breaking changes
- [ ] All public APIs reviewed for Swift naming conventions and consistency
- [ ] Breaking changes (if any) documented with migration examples
- [ ] No known P0 or P1 bugs

---

## 4. Technical Details & Guidance

### 4.1 Linux Backend Architecture

#### 4.1.1 X11 Implementation
- **Library Choice**: Use XCB (X protocol C binding) for lower-level control and better async support vs Xlib
- **Connection Management**: Single X connection per application; thread safety via locks or serial queue
- **Event Handling**: XCB event polling integrates with Swift's event loop (GCD/Dispatch or custom run loop)
- **Window Manager Hints**: Set EWMH (Extended Window Manager Hints) properties for decorations, size constraints, state
- **Atoms**: Cache commonly used atoms (WM_DELETE_WINDOW, _NET_WM_STATE, etc.) at startup
- **XKB Integration**: Use X Keyboard Extension for proper keyboard handling, layout awareness
- **XInput2**: Use XInput2 for pointer events to get smooth scrolling and button events
- **DPI Detection**: Query Xft.dpi, XSETTINGS, or calculate from screen physical dimensions
- **Error Handling**: X11 errors are async; install error handler to avoid crashes

#### 4.1.2 Wayland Implementation
- **Protocol Bindings**: Generate Swift bindings from Wayland XML protocol specs (wayland.xml, xdg-shell.xml)
- **Core Protocols**: Implement wl_surface, wl_compositor, xdg_surface, xdg_toplevel for basic windows
- **Compositor Feature Detection**: Check for required globals at startup; error clearly if missing
- **Keyboard Handling**: Integrate with libxkbcommon for keymap interpretation
- **Pointer & Touch**: Implement wl_pointer, wl_seat protocols
- **Scale Factor**: Use wl_output scale information and fractional-scale protocol if available
- **Client-Side Decorations**: Implement basic CSD rendering or integrate libdecor for consistent look
- **Event Loop Integration**: Wayland fd polling fits into Swift's event loop via DispatchSource
- **Buffer Management**: Use wl_shm (shared memory) for software rendering surfaces initially

#### 4.1.3 Shared Linux Infrastructure
- **Platform Abstraction**: Define `LinuxBackend` protocol with X11 and Wayland conformances
- **Runtime Selection**: Choose backend based on environment variables (WAYLAND_DISPLAY, DISPLAY) or explicit API
- **Conditional Compilation**: Use Swift conditional compilation for platform-specific code paths
- **Shared Types**: Unify event types, window IDs, and coordinate systems across backends

---

### 4.2 Wave B — macOS Redraw & Control Flow

#### 4.2.1 Redraw Contract Implementation
- **NSView Integration**: Leverage `setNeedsDisplay` and `draw(_:)` callbacks; map to Lumina's `RedrawRequested` event
- **Resize Coalescing**: Use `inLiveResize` property to detect resize drag; coalesce events using a timer or display link
- **CADisplayLink**: For frame pacing, integrate CADisplayLink to sync redraws with screen refresh (60Hz, 120Hz ProMotion)
- **Dirty Regions**: Expose NSView's `dirtyRect` in RedrawRequested event when available
- **Explicit Requests**: Provide `window.requestRedraw()` that triggers `setNeedsDisplay`

#### 4.2.2 Control Flow Modes
- **NSRunLoop Integration**: Lumina's event loop wraps `NSRunLoop.main`
- **Wait Mode**: Use `run(until:)` with distant future date; block until events arrive
- **Poll Mode**: Use `limitDate(forMode:)` with immediate timeout; process available events and return
- **WaitUntil Mode**: Use `run(until:)` with specified deadline (Date or DispatchTime)
- **Custom Run Loop Sources**: Integrate user events via CFRunLoopSource or Dispatch sources

#### 4.2.3 Window Decorations & Transparency
- **NSWindow Style Masks**: Toggle `titled`, `closable`, `miniaturizable`, `resizable` at runtime
- **Always-On-Top**: Set window level to `NSWindow.Level.floating` or `.popUpMenu`
- **Transparency**: Set `isOpaque = false` and `backgroundColor = .clear` on NSWindow
- **Traffic Lights**: Use `standardWindowButton(:)` to control title bar button visibility
- **Frameless Windows**: Use `styleMask = .borderless` for fully custom windows

#### 4.2.4 Clipboard Integration (macOS)
- **NSPasteboard**: Wrap `NSPasteboard.general` for clipboard operations
- **Text Types**: Read/write `NSPasteboard.PasteboardType.string`
- **Change Count**: Track `changeCount` to detect external modifications
- **Thread Safety**: NSPasteboard is main-thread-only; marshal calls appropriately
- **Error Handling**: Handle cases where clipboard is locked or unavailable

#### 4.2.5 Monitor Enumeration (macOS)
- **NSScreen**: Use `NSScreen.screens` to enumerate displays
- **Primary Monitor**: `NSScreen.main` is the screen with keyboard focus
- **Geometry**: `frame` property gives global coordinates in Cocoa coordinate space (origin bottom-left)
- **Work Area**: `visibleFrame` excludes menu bar and dock
- **Scale Factor**: `backingScaleFactor` provides HiDPI scale (1.0 or 2.0)
- **Change Notifications**: Observe `NSApplication.didChangeScreenParametersNotification`

---

### 4.3 Cross-Platform API Design

#### 4.3.1 Type Safety & Clarity
- **Distinct Types**: Use distinct types for `LogicalSize`/`PhysicalSize`, `LogicalPosition`/`PhysicalPosition`
- **Scale Factor Type**: `ScaleFactor` newtype wrapping `Double` to prevent confusion
- **Coordinate Systems**: Document origin conventions (top-left on Windows/Linux, bottom-left on macOS internally)
- **Unit Conversions**: Provide safe conversion methods: `logical.toPhysical(scale)`, `physical.toLogical(scale)`

#### 4.3.2 Event Types
- **Exhaustive Enums**: Use enums for event types with associated values
- **Timestamp**: Include high-resolution timestamp in all events (monotonic clock)
- **Window ID**: All window-related events carry a `WindowId` to route events in multi-window apps
- **Modifier State**: Input events include snapshot of modifier keys at event time

#### 4.3.3 Capability Flags
- **Runtime Queries**: `window.capabilities.supportsTransparency`, `platform.capabilities.supportsWaylandProtocol(_:)`
- **Compile-Time Checks**: Use `#if os(Linux)` etc. for platform-specific code in examples
- **Graceful Degradation**: APIs that may fail on some platforms return `Result<T, Error>` or throw
- **Documentation Annotations**: Mark APIs with `@available` or doc comments indicating platform support

---

### 4.4 Testing Strategy

#### 4.4.1 Unit Tests
- **Pure Logic Tests**: Test event parsing, coordinate conversions, state machines without OS integration
- **Mock Backends**: Create mock platform backends to test application logic in isolation
- **Property-Based Tests**: Use Swift Testing's randomized inputs for coordinate conversions, scale factors

#### 4.4.2 Integration Tests
- **Headless Mode**: X11 tests run under Xvfb (virtual framebuffer); Wayland tests use Weston or Sway in headless mode
- **Event Synthesis**: Programmatically inject input events (XTest for X11, uinput or wl_test protocols for Wayland)
- **Golden Traces**: Record expected event sequences for interactions (click, drag, resize); replay and compare

#### 4.4.3 Platform-Specific Tests
- **X11 Tests**: Verify EWMH compliance, window manager interop with various WMs (Mutter, KWin, i3)
- **Wayland Tests**: Test protocol negotiation, CSD rendering, multiple compositors (GNOME Shell, KDE Plasma, Sway)
- **macOS Tests**: Verify NSWindow integration, CADisplayLink frame pacing, NSPasteboard threading

#### 4.4.4 Manual Testing Checklist
- **DPI Scaling**: Move window between monitors with different scale factors; verify rendering sharpness
- **Input Coverage**: Test all mouse buttons, scroll wheel, keyboard layouts, modifier combos
- **Window States**: Test minimize, maximize, fullscreen entry/exit, focus changes
- **Clipboard Interop**: Copy from Lumina, paste into TextEdit/gedit/Kate; copy from external app, paste into Lumina
- **Stress Tests**: Create 100 windows, rapidly resize, send 10k events/sec

---

### 4.5 Dependencies & Build System

#### 4.5.1 Linux Dependencies
- **X11**: libxcb, libxcb-keysyms, libxcb-xkb, libxcb-xinput, libxkbcommon
- **Wayland**: libwayland-client, libxkbcommon, libdecor (optional for CSD)
- **Package Managers**: Document installation commands for apt, dnf, pacman
- **Swift Package Manager**: Add system library targets for C dependencies

#### 4.5.2 Build Configuration
- **Conditional Compilation**: Use `#if os(Linux)` to guard Linux-specific code
- **Feature Flags**: Consider SPM feature flags for X11-only or Wayland-only builds
- **Link Libraries**: Specify linker settings for Linux system libraries

---

### 4.6 Risk Mitigation

#### 4.6.1 Wayland Fragmentation
- **Risk**: Compositors implement different subsets of protocols; features may be unavailable
- **Mitigation**:
  - Implement core protocols first (xdg-shell v2+)
  - Use capability detection and feature gates
  - Document supported compositors and protocol versions
  - Provide clear error messages when features unavailable

#### 4.6.2 X11 Window Manager Variations
- **Risk**: WMs have different EWMH compliance levels; decorations/constraints may not work
- **Mitigation**:
  - Test on major WMs (Mutter, KWin, Xfwm, i3, Openbox)
  - Use lowest-common-denominator EWMH features
  - Document known WM quirks in compatibility matrix

#### 4.6.3 DPI Scaling Inconsistencies
- **Risk**: X11 DPI detection is unreliable; mixed-DPI setups have edge cases
- **Mitigation**:
  - Prefer XSETTINGS daemon values when available
  - Fall back to calculated DPI from physical dimensions
  - Provide manual override API for applications
  - Test extensively on mixed-DPI configurations

#### 4.6.4 Thread Safety (macOS)
- **Risk**: AppKit is main-thread-only; cross-thread API calls cause crashes
- **Mitigation**:
  - All window/UI operations funnel through main dispatch queue
  - Document threading requirements clearly
  - Use precondition checks to catch misuse early
  - Provide thread-safe user event posting API

---

## 5. Success Criteria

Milestone 1 is considered successful when:

1. **Cross-Platform Parity**: A single Lumina application binary runs on macOS, Windows (from M0), and Linux (X11 + Wayland) with identical behavior for Wave A features
2. **Robustness Foundation**: macOS Wave B features demonstrate the redraw contract and control flow model that will be replicated on other platforms in M2
3. **Developer Experience**: Linux developers can install dependencies, build Lumina, and run examples in under 10 minutes
4. **Quality Bar**: Zero P0 bugs, manual test checklists 100% complete
5. **Documentation**: Examples clearly demonstrate new features; API docs have no missing sections
6. **Community Readiness**: Linux users can begin experimenting with Lumina for real projects (acknowledge 0.2.x status)

---

## 6. Post-M1 Roadmap Preview

Upon M1 completion, the project moves to M2:

- **Wave B (Windows/Linux)**: Redraw contract, decorations, clipboard, monitors on Windows and Linux
- **Wave C (macOS)**: Advanced keyboard (scancodes, dead keys), IME phase 1, pointer constraints, raw input
- **Testing Infrastructure**: Expand golden trace tests, add IME composition tests (EN/JP/ZH)
- **Performance Tuning**: Optimize event loop latency, memory footprint

---

## 7. References

- [PLAN.md](../PLAN.md) — Overall feature roadmap and wave definitions
- [Wayland Protocol Spec](https://wayland.freedesktop.org/docs/html/) — Core Wayland protocol documentation
- [XCB Documentation](https://xcb.freedesktop.org/) — X11 protocol C bindings
- [EWMH Spec](https://specifications.freedesktop.org/wm-spec/wm-spec-latest.html) — Extended Window Manager Hints
- [libxkbcommon](https://xkbcommon.org/) — Keyboard handling library for Wayland/X11
- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/) — macOS window behavior expectations

---

**Document Version**: 1.0
**Last Updated**: 2025-10-20
**Owner**: Lumina Core Team
